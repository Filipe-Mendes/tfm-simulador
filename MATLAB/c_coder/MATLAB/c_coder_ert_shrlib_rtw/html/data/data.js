var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"c_coder","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"c_coder.h\"                   /* Model's header file */\r\n\r\nstatic RT_MODEL_c_coder_T c_coder_M_;\r\nstatic RT_MODEL_c_coder_T *const c_coder_MPtr = &c_coder_M_;/* Real-time model */\r\nstatic B_c_coder_T c_coder_B;          /* Observable signals */\r\nstatic DW_c_coder_T c_coder_DW;        /* Observable states */\r\nstatic X_c_coder_T c_coder_X;          /* Observable continuous states */\r\n\r\n/* '<Root>/Inport' */\r\nstatic real_T c_coder_U_Inport;\r\n\r\n/* '<Root>/Inport1' */\r\nstatic real_T c_coder_U_Inport1;\r\n\r\n/* '<Root>/Inport2' */\r\nstatic real_T c_coder_U_Inport2;\r\n\r\n/* '<Root>/Inport3' */\r\nstatic real_T c_coder_U_Inport3;\r\n\r\n/* '<Root>/Inport4' */\r\nstatic real_T c_coder_U_Inport4;\r\n\r\n/* '<Root>/Inport5' */\r\nstatic real_T c_coder_U_Inport5;\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(RT_MODEL_c_coder_T *const c_coder_M);\r\nvoid rt_OneStep(RT_MODEL_c_coder_T *const c_coder_M)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(c_coder_M, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model for base rate */\r\n  c_coder_step(c_coder_M, c_coder_U_Inport, c_coder_U_Inport1, c_coder_U_Inport2,\r\n               c_coder_U_Inport3, c_coder_U_Inport4, c_coder_U_Inport5);\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example \"main\" function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific.  This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  RT_MODEL_c_coder_T *const c_coder_M = c_coder_MPtr;\r\n\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Pack model data into RTM */\r\n  c_coder_M->blockIO = &c_coder_B;\r\n  c_coder_M->dwork = &c_coder_DW;\r\n  c_coder_M->contStates = &c_coder_X;\r\n\r\n  /* Initialize model */\r\n  c_coder_initialize(c_coder_M, &c_coder_U_Inport, &c_coder_U_Inport1,\r\n                     &c_coder_U_Inport2, &c_coder_U_Inport3, &c_coder_U_Inport4,\r\n                     &c_coder_U_Inport5);\r\n\r\n  /* Simulating the model step behavior (in non real-time) to\r\n   *  simulate model behavior at stop time.\r\n   */\r\n  while ((rtmGetErrorStatus(c_coder_M) == (NULL)) && !rtmGetStopRequested\r\n         (c_coder_M)) {\r\n    rt_OneStep(c_coder_M);\r\n  }\r\n\r\n  /* Disable rt_OneStep here */\r\n  /* Terminate model */\r\n  c_coder_terminate(c_coder_M);\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"c_coder.c","type":"source","group":"model","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: c_coder.c\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"c_coder.h\"\r\n#include \"c_coder_private.h\"\r\n\r\n/* user code (top of source file) */\r\n#include <stdint.h>\r\n\r\n__declspec(dllexport) void wrapper_c_coder_step(RT_MODEL_c_coder_T *const\r\n  c_coder_M,\r\n  real_T c_coder_U_Inport,\r\n  real_T c_coder_U_Inport1,\r\n  real_T c_coder_U_Inport2,\r\n  real_T c_coder_U_Inport3,\r\n  real_T c_coder_U_Inport4,\r\n  real_T c_coder_U_Inport5)\r\n{\r\n  //printf(\"INSIDE DLL BEFORE\");\r\n  //for (int i = 0; i < 25; ++i) {\r\n  //    printf(\"%u \", out1[i]);\r\n  //}\r\n  c_coder_step(c_coder_M, c_coder_U_Inport, c_coder_U_Inport1, c_coder_U_Inport2,\r\n               c_coder_U_Inport3, c_coder_U_Inport4, c_coder_U_Inport5);\r\n\r\n  //printf(\"INSIDE DLL AFTER\");\r\n  //for (int i = 0; i < 25; ++i) {\r\n  //    printf(\"%u \", out1[i]);\r\n  //}\r\n}\r\n\r\n__declspec(dllexport) void wrapper_c_coder_initialize(RT_MODEL_c_coder_T *const\r\n  c_coder_M,\r\n  real_T c_coder_U_Inport,\r\n  real_T c_coder_U_Inport1,\r\n  real_T c_coder_U_Inport2,\r\n  real_T c_coder_U_Inport3,\r\n  real_T c_coder_U_Inport4,\r\n  real_T c_coder_U_Inport5)\r\n{\r\n  c_coder_initialize(c_coder_M, &c_coder_U_Inport, &c_coder_U_Inport1,\r\n                     &c_coder_U_Inport2, &c_coder_U_Inport3, &c_coder_U_Inport4,\r\n                     &c_coder_U_Inport5);\r\n}\r\n\r\n__declspec(dllexport) int *getOutput()\r\n{\r\n  return out1;\r\n}\r\n\r\n/* Exported block signals */\r\nuint8_T out1[25];                      /* '<Root>/Out1' */\r\n\r\n/*\r\n * This function updates continuous states using the ODE3 fixed-step\r\n * solver algorithm\r\n */\r\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si ,\r\n  RT_MODEL_c_coder_T *const c_coder_M, real_T c_coder_U_Inport, real_T\r\n  c_coder_U_Inport1, real_T c_coder_U_Inport2, real_T c_coder_U_Inport3, real_T\r\n  c_coder_U_Inport4, real_T c_coder_U_Inport5)\r\n{\r\n  /* Solver Matrices */\r\n  static const real_T rt_ODE3_A[3] = {\r\n    1.0/2.0, 3.0/4.0, 1.0\r\n  };\r\n\r\n  static const real_T rt_ODE3_B[3][3] = {\r\n    { 1.0/2.0, 0.0, 0.0 },\r\n\r\n    { 0.0, 3.0/4.0, 0.0 },\r\n\r\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\r\n  };\r\n\r\n  time_T t = rtsiGetT(si);\r\n  time_T tnew = rtsiGetSolverStopTime(si);\r\n  time_T h = rtsiGetStepSize(si);\r\n  real_T *x = rtsiGetContStates(si);\r\n  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);\r\n  real_T *y = id->y;\r\n  real_T *f0 = id->f[0];\r\n  real_T *f1 = id->f[1];\r\n  real_T *f2 = id->f[2];\r\n  real_T hB[3];\r\n  int_T i;\r\n  int_T nXc = 11;\r\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\r\n\r\n  /* Save the state values at time t in y, we'll use x as ynew. */\r\n  (void) memcpy(y, x,\r\n                (uint_T)nXc*sizeof(real_T));\r\n\r\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\r\n  /* f0 = f(t,y) */\r\n  rtsiSetdX(si, f0);\r\n  c_coder_derivatives(c_coder_M);\r\n\r\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\r\n  hB[0] = h * rt_ODE3_B[0][0];\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\r\n  rtsiSetdX(si, f1);\r\n  c_coder_step(c_coder_M, c_coder_U_Inport, c_coder_U_Inport1, c_coder_U_Inport2,\r\n               c_coder_U_Inport3, c_coder_U_Inport4, c_coder_U_Inport5);\r\n  c_coder_derivatives(c_coder_M);\r\n\r\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\r\n  for (i = 0; i <= 1; i++) {\r\n    hB[i] = h * rt_ODE3_B[1][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\r\n  rtsiSetdX(si, f2);\r\n  c_coder_step(c_coder_M, c_coder_U_Inport, c_coder_U_Inport1, c_coder_U_Inport2,\r\n               c_coder_U_Inport3, c_coder_U_Inport4, c_coder_U_Inport5);\r\n  c_coder_derivatives(c_coder_M);\r\n\r\n  /* tnew = t + hA(3);\r\n     ynew = y + f*hB(:,3); */\r\n  for (i = 0; i <= 2; i++) {\r\n    hB[i] = h * rt_ODE3_B[2][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\r\n  }\r\n\r\n  rtsiSetT(si, tnew);\r\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\r\n}\r\n\r\nreal_T rt_powd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else {\r\n    real_T tmp;\r\n    real_T tmp_0;\r\n    tmp = fabs(u0);\r\n    tmp_0 = fabs(u1);\r\n    if (rtIsInf(u1)) {\r\n      if (tmp == 1.0) {\r\n        y = 1.0;\r\n      } else if (tmp > 1.0) {\r\n        if (u1 > 0.0) {\r\n          y = (rtInf);\r\n        } else {\r\n          y = 0.0;\r\n        }\r\n      } else if (u1 > 0.0) {\r\n        y = 0.0;\r\n      } else {\r\n        y = (rtInf);\r\n      }\r\n    } else if (tmp_0 == 0.0) {\r\n      y = 1.0;\r\n    } else if (tmp_0 == 1.0) {\r\n      if (u1 > 0.0) {\r\n        y = u0;\r\n      } else {\r\n        y = 1.0 / u0;\r\n      }\r\n    } else if (u1 == 2.0) {\r\n      y = u0 * u0;\r\n    } else if ((u1 == 0.5) && (u0 >= 0.0)) {\r\n      y = sqrt(u0);\r\n    } else if ((u0 < 0.0) && (u1 > floor(u1))) {\r\n      y = (rtNaN);\r\n    } else {\r\n      y = pow(u0, u1);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid c_coder_step(RT_MODEL_c_coder_T *const c_coder_M, real_T c_coder_U_Inport,\r\n                  real_T c_coder_U_Inport1, real_T c_coder_U_Inport2, real_T\r\n                  c_coder_U_Inport3, real_T c_coder_U_Inport4, real_T\r\n                  c_coder_U_Inport5)\r\n{\r\n  B_c_coder_T *c_coder_B = c_coder_M->blockIO;\r\n  DW_c_coder_T *c_coder_DW = c_coder_M->dwork;\r\n  X_c_coder_T *c_coder_X = c_coder_M->contStates;\r\n  if (rtmIsMajorTimeStep(c_coder_M)) {\r\n    /* set solver stop time */\r\n    rtsiSetSolverStopTime(&c_coder_M->solverInfo,((c_coder_M->Timing.clockTick0+\r\n      1)*c_coder_M->Timing.stepSize0));\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  /* Update absolute time of base rate at minor time step */\r\n  if (rtmIsMinorTimeStep(c_coder_M)) {\r\n    c_coder_M->Timing.t[0] = rtsiGetT(&c_coder_M->solverInfo);\r\n  }\r\n\r\n  {\r\n    real_T tmp;\r\n    real_T tmp_0;\r\n    real_T tmp_idx_1;\r\n    real_T *lastU;\r\n\r\n    /* RelationalOperator: '<S1>/Compare' incorporates:\r\n     *  Constant: '<S1>/Constant'\r\n     *  Inport: '<Root>/Inport3'\r\n     *  Inport: '<Root>/Inport4'\r\n     *  Inport: '<Root>/Inport5'\r\n     */\r\n    c_coder_B->Compare[0] = (c_coder_U_Inport3 <= 180.0);\r\n    c_coder_B->Compare[1] = (c_coder_U_Inport4 <= 180.0);\r\n    c_coder_B->Compare[2] = (c_coder_U_Inport5 <= 180.0);\r\n\r\n    /* Sum: '<Root>/Sum2' incorporates:\r\n     *  Constant: '<Root>/Constant'\r\n     *  Inport: '<Root>/Inport3'\r\n     *  Inport: '<Root>/Inport4'\r\n     *  Inport: '<Root>/Inport5'\r\n     */\r\n    c_coder_B->Sum2[0] = c_coder_U_Inport3 - 360.0;\r\n    c_coder_B->Sum2[1] = c_coder_U_Inport4 - 360.0;\r\n    c_coder_B->Sum2[2] = c_coder_U_Inport5 - 360.0;\r\n\r\n    /* Switch: '<Root>/Switch' incorporates:\r\n     *  Inport: '<Root>/Inport3'\r\n     *  Inport: '<Root>/Inport4'\r\n     *  Inport: '<Root>/Inport5'\r\n     */\r\n    tmp = c_coder_U_Inport3;\r\n    tmp_idx_1 = c_coder_U_Inport4;\r\n    tmp_0 = c_coder_U_Inport5;\r\n    if (c_coder_B->Compare[0]) {\r\n      c_coder_B->Switch[0] = tmp;\r\n    } else {\r\n      c_coder_B->Switch[0] = c_coder_B->Sum2[0];\r\n    }\r\n\r\n    if (c_coder_B->Compare[1]) {\r\n      c_coder_B->Switch[1] = tmp_idx_1;\r\n    } else {\r\n      c_coder_B->Switch[1] = c_coder_B->Sum2[1];\r\n    }\r\n\r\n    if (c_coder_B->Compare[2]) {\r\n      c_coder_B->Switch[2] = tmp_0;\r\n    } else {\r\n      c_coder_B->Switch[2] = c_coder_B->Sum2[2];\r\n    }\r\n\r\n    /* End of Switch: '<Root>/Switch' */\r\n\r\n    /* Gain: '<Root>/Gain3' */\r\n    c_coder_B->Gain3 = (-1.0) * c_coder_B->Switch[2];\r\n\r\n    /* Saturate: '<Root>/Saturation2' */\r\n    tmp = c_coder_B->Gain3;\r\n    tmp_idx_1 = (-15.0);\r\n    tmp_0 = 15.0;\r\n    if (tmp > tmp_0) {\r\n      /* Saturate: '<Root>/Saturation2' */\r\n      c_coder_B->Saturation2 = tmp_0;\r\n    } else if (tmp < tmp_idx_1) {\r\n      /* Saturate: '<Root>/Saturation2' */\r\n      c_coder_B->Saturation2 = tmp_idx_1;\r\n    } else {\r\n      /* Saturate: '<Root>/Saturation2' */\r\n      c_coder_B->Saturation2 = tmp;\r\n    }\r\n\r\n    /* End of Saturate: '<Root>/Saturation2' */\r\n\r\n    /* Product: '<S8>/Product5' incorporates:\r\n     *  Constant: '<S8>/Constant4'\r\n     *  Constant: '<S8>/Constant5'\r\n     */\r\n    c_coder_B->Product5 = c_coder_B->Saturation2 * 3.1415926535897931 / 180.0;\r\n\r\n    /* Trigonometry: '<S6>/Trigonometric Function1' */\r\n    c_coder_B->TrigonometricFunction1 = cos(c_coder_B->Product5);\r\n\r\n    /* Product: '<S6>/Product1' incorporates:\r\n     *  Constant: '<S4>/Constant7'\r\n     */\r\n    c_coder_B->z = c_coder_B->TrigonometricFunction1 * 180.0;\r\n\r\n    /* Gain: '<Root>/Gain2' */\r\n    c_coder_B->Gain2 = 1.0 * c_coder_B->Switch[0];\r\n\r\n    /* Saturate: '<Root>/Saturation1' */\r\n    tmp = c_coder_B->Gain2;\r\n    tmp_idx_1 = (-15.0);\r\n    tmp_0 = 15.0;\r\n    if (tmp > tmp_0) {\r\n      /* Saturate: '<Root>/Saturation1' */\r\n      c_coder_B->Saturation1 = tmp_0;\r\n    } else if (tmp < tmp_idx_1) {\r\n      /* Saturate: '<Root>/Saturation1' */\r\n      c_coder_B->Saturation1 = tmp_idx_1;\r\n    } else {\r\n      /* Saturate: '<Root>/Saturation1' */\r\n      c_coder_B->Saturation1 = tmp;\r\n    }\r\n\r\n    /* End of Saturate: '<Root>/Saturation1' */\r\n\r\n    /* Product: '<S9>/Product5' incorporates:\r\n     *  Constant: '<S9>/Constant4'\r\n     *  Constant: '<S9>/Constant5'\r\n     */\r\n    c_coder_B->Product5_e = c_coder_B->Saturation1 * 3.1415926535897931 / 180.0;\r\n\r\n    /* Trigonometry: '<S6>/Trigonometric Function2' */\r\n    c_coder_B->TrigonometricFunction2 = sin(c_coder_B->Product5_e);\r\n\r\n    /* Product: '<S6>/Product2' */\r\n    c_coder_B->x = c_coder_B->z * c_coder_B->TrigonometricFunction2;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator5' */\r\n      c_coder_B->posx = c_coder_DW->DiscreteTimeIntegrator5_DSTATE;\r\n    }\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn13' */\r\n    c_coder_B->TransferFcn13 = 0.0;\r\n    c_coder_B->TransferFcn13 += (-6.2831853071795862) *\r\n      c_coder_X->TransferFcn13_CSTATE;\r\n    c_coder_B->TransferFcn13 += 1.0 * c_coder_B->posx;\r\n\r\n    /* Saturate: '<Root>/Saturation6' */\r\n    tmp = c_coder_B->TransferFcn13;\r\n    tmp_idx_1 = (-250.0);\r\n    tmp_0 = 250.0;\r\n    if (tmp > tmp_0) {\r\n      /* Saturate: '<Root>/Saturation6' */\r\n      c_coder_B->posx_filt = tmp_0;\r\n    } else if (tmp < tmp_idx_1) {\r\n      /* Saturate: '<Root>/Saturation6' */\r\n      c_coder_B->posx_filt = tmp_idx_1;\r\n    } else {\r\n      /* Saturate: '<Root>/Saturation6' */\r\n      c_coder_B->posx_filt = tmp;\r\n    }\r\n\r\n    /* End of Saturate: '<Root>/Saturation6' */\r\n\r\n    /* Sum: '<S6>/Sum' */\r\n    c_coder_B->Sum = c_coder_B->x + c_coder_B->posx_filt;\r\n\r\n    /* Trigonometry: '<S6>/Trigonometric Function' */\r\n    c_coder_B->TrigonometricFunction = sin(c_coder_B->Product5);\r\n\r\n    /* Product: '<S6>/Product' incorporates:\r\n     *  Constant: '<S4>/Constant7'\r\n     */\r\n    c_coder_B->y = c_coder_B->TrigonometricFunction * 180.0;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator4' */\r\n      c_coder_B->DiscreteTimeIntegrator4 =\r\n        c_coder_DW->DiscreteTimeIntegrator4_DSTATE;\r\n    }\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn11' */\r\n    c_coder_B->TransferFcn11 = 0.0;\r\n    c_coder_B->TransferFcn11 += (-6.2831853071795862) *\r\n      c_coder_X->TransferFcn11_CSTATE;\r\n    c_coder_B->TransferFcn11 += 1.0 * c_coder_B->DiscreteTimeIntegrator4;\r\n\r\n    /* Saturate: '<Root>/Saturation4' */\r\n    tmp = c_coder_B->TransferFcn11;\r\n    tmp_idx_1 = (-250.0);\r\n    tmp_0 = 250.0;\r\n    if (tmp > tmp_0) {\r\n      /* Saturate: '<Root>/Saturation4' */\r\n      c_coder_B->Saturation4 = tmp_0;\r\n    } else if (tmp < tmp_idx_1) {\r\n      /* Saturate: '<Root>/Saturation4' */\r\n      c_coder_B->Saturation4 = tmp_idx_1;\r\n    } else {\r\n      /* Saturate: '<Root>/Saturation4' */\r\n      c_coder_B->Saturation4 = tmp;\r\n    }\r\n\r\n    /* End of Saturate: '<Root>/Saturation4' */\r\n\r\n    /* Sum: '<S6>/Sum1' */\r\n    c_coder_B->Sum1 = c_coder_B->y + c_coder_B->Saturation4;\r\n\r\n    /* Trigonometry: '<S6>/Trigonometric Function3' */\r\n    c_coder_B->TrigonometricFunction3 = cos(c_coder_B->Product5_e);\r\n\r\n    /* Product: '<S6>/Product3' */\r\n    c_coder_B->z_n = c_coder_B->z * c_coder_B->TrigonometricFunction3;\r\n\r\n    /* Sum: '<S6>/Sum2' incorporates:\r\n     *  Constant: '<Root>/Constant5'\r\n     *  Constant: '<S4>/Constant5'\r\n     */\r\n    c_coder_B->Sum2_n = (1100.0 - c_coder_B->z_n) - 180.0;\r\n\r\n    /* Fcn: '<S7>/XT1' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->XT1 = ((sin(c_coder_B->Product5) * sin(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + cos(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * -0.16666666666666666 *\r\n                      1.7320508075688772 * (2.0 * 690.0 + 220.0) + (sin\r\n      (c_coder_B->Product5) * sin(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + -cos(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * 220.0) + c_coder_B->Sum;\r\n\r\n    /* Fcn: '<S7>/YT1' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->YT1 = (-0.16666666666666666 * cos(c_coder_B->Product5) * sin\r\n                      (c_coder_ConstB.Product5) * 1.7320508075688772 * (2.0 *\r\n      690.0 + 220.0) + 0.5 * cos(c_coder_B->Product5) * cos\r\n                      (c_coder_ConstB.Product5) * 220.0) + c_coder_B->Sum1;\r\n\r\n    /* Fcn: '<S7>/ZT1' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->ZT1 = ((sin(c_coder_B->Product5) * cos(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + -sin(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * -0.16666666666666666 *\r\n                      1.7320508075688772 * (2.0 * 690.0 + 220.0) + (sin\r\n      (c_coder_B->Product5) * cos(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + sin(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * 220.0) + c_coder_B->Sum2_n;\r\n\r\n    /* Fcn: '<S7>/XT2' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->XT2 = ((sin(c_coder_B->Product5) * sin(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + cos(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * 0.16666666666666666 *\r\n                      1.7320508075688772 * (690.0 - 220.0) + (sin\r\n      (c_coder_B->Product5) * sin(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + -cos(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) / 2.0 * (690.0 + 220.0)) + c_coder_B->Sum;\r\n\r\n    /* Fcn: '<S7>/YT2' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->YT2 = (0.16666666666666666 * cos(c_coder_B->Product5) * sin\r\n                      (c_coder_ConstB.Product5) * 1.7320508075688772 * (690.0 -\r\n      220.0) + 0.5 * cos(c_coder_B->Product5) * cos(c_coder_ConstB.Product5) *\r\n                      (690.0 + 220.0)) + c_coder_B->Sum1;\r\n\r\n    /* Fcn: '<S7>/ZT2' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->ZT2 = ((sin(c_coder_B->Product5) * cos(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + -sin(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * 0.16666666666666666 *\r\n                      1.7320508075688772 * (690.0 - 220.0) + (sin\r\n      (c_coder_B->Product5) * cos(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + sin(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * (690.0 + 220.0)) + c_coder_B->Sum2_n;\r\n\r\n    /* Fcn: '<S7>/XT3' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->XT3 = ((sin(c_coder_B->Product5) * sin(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + cos(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * 0.16666666666666666 *\r\n                      1.7320508075688772 * (2.0 * 220.0 + 690.0) + (sin\r\n      (c_coder_B->Product5) * sin(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + -cos(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * 690.0) + c_coder_B->Sum;\r\n\r\n    /* Fcn: '<S7>/YT3' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->YT3 = (0.16666666666666666 * cos(c_coder_B->Product5) * sin\r\n                      (c_coder_ConstB.Product5) * 1.7320508075688772 * (2.0 *\r\n      220.0 + 690.0) + 0.5 * cos(c_coder_B->Product5) * cos\r\n                      (c_coder_ConstB.Product5) * 690.0) + c_coder_B->Sum1;\r\n\r\n    /* Fcn: '<S7>/ZT3' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->ZT3 = ((sin(c_coder_B->Product5) * cos(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + -sin(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * 0.16666666666666666 *\r\n                      1.7320508075688772 * (2.0 * 220.0 + 690.0) + (sin\r\n      (c_coder_B->Product5) * cos(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + sin(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * 690.0) + c_coder_B->Sum2_n;\r\n\r\n    /* Fcn: '<S7>/XT4' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->XT4 = ((sin(c_coder_B->Product5) * sin(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + cos(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * 0.16666666666666666 *\r\n                      1.7320508075688772 * (2.0 * 220.0 + 690.0) - (sin\r\n      (c_coder_B->Product5) * sin(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + -cos(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * 690.0) + c_coder_B->Sum;\r\n\r\n    /* Fcn: '<S7>/YT4' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->YT4 = (0.16666666666666666 * cos(c_coder_B->Product5) * sin\r\n                      (c_coder_ConstB.Product5) * 1.7320508075688772 * (2.0 *\r\n      220.0 + 690.0) - 0.5 * cos(c_coder_B->Product5) * cos\r\n                      (c_coder_ConstB.Product5) * 690.0) + c_coder_B->Sum1;\r\n\r\n    /* Fcn: '<S7>/ZT4' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->ZT4 = ((sin(c_coder_B->Product5) * cos(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + -sin(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * 0.16666666666666666 *\r\n                      1.7320508075688772 * (2.0 * 220.0 + 690.0) - (sin\r\n      (c_coder_B->Product5) * cos(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + sin(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * 690.0) + c_coder_B->Sum2_n;\r\n\r\n    /* Fcn: '<S7>/XT5' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->XT5 = ((sin(c_coder_B->Product5) * sin(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + cos(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * 0.16666666666666666 *\r\n                      1.7320508075688772 * (690.0 - 220.0) - (sin\r\n      (c_coder_B->Product5) * sin(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + -cos(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * (690.0 + 220.0)) + c_coder_B->Sum;\r\n\r\n    /* Fcn: '<S7>/YT5' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->YT5 = (0.16666666666666666 * cos(c_coder_B->Product5) * sin\r\n                      (c_coder_ConstB.Product5) * 1.7320508075688772 * (690.0 -\r\n      220.0) - 0.5 * cos(c_coder_B->Product5) * cos(c_coder_ConstB.Product5) *\r\n                      (690.0 + 220.0)) + c_coder_B->Sum1;\r\n\r\n    /* Fcn: '<S7>/ZT5' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->ZT5 = ((sin(c_coder_B->Product5) * cos(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + -sin(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * 0.16666666666666666 *\r\n                      1.7320508075688772 * (690.0 - 220.0) - (sin\r\n      (c_coder_B->Product5) * cos(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + sin(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * (690.0 + 220.0)) + c_coder_B->Sum2_n;\r\n\r\n    /* Fcn: '<S7>/XT6' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->XT6 = ((sin(c_coder_B->Product5) * sin(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + cos(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * -0.16666666666666666 *\r\n                      1.7320508075688772 * (2.0 * 690.0 + 220.0) - (sin\r\n      (c_coder_B->Product5) * sin(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + -cos(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * 220.0) + c_coder_B->Sum;\r\n\r\n    /* Fcn: '<S7>/YT6' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->YT6 = (-0.16666666666666666 * cos(c_coder_B->Product5) * sin\r\n                      (c_coder_ConstB.Product5) * 1.7320508075688772 * (2.0 *\r\n      690.0 + 220.0) - 0.5 * cos(c_coder_B->Product5) * cos\r\n                      (c_coder_ConstB.Product5) * 220.0) + c_coder_B->Sum1;\r\n\r\n    /* Fcn: '<S7>/ZT6' incorporates:\r\n     *  Constant: '<S4>/Constant2'\r\n     *  Constant: '<S4>/Constant3'\r\n     */\r\n    c_coder_B->ZT6 = ((sin(c_coder_B->Product5) * cos(c_coder_B->Product5_e) *\r\n                       sin(c_coder_ConstB.Product5) + -sin(c_coder_B->Product5_e)\r\n                       * cos(c_coder_ConstB.Product5)) * -0.16666666666666666 *\r\n                      1.7320508075688772 * (2.0 * 690.0 + 220.0) - (sin\r\n      (c_coder_B->Product5) * cos(c_coder_B->Product5_e) * cos\r\n      (c_coder_ConstB.Product5) + sin(c_coder_B->Product5_e) * sin\r\n      (c_coder_ConstB.Product5)) * 0.5 * 220.0) + c_coder_B->Sum2_n;\r\n\r\n    /* Fcn: '<S7>/XB1' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->XB1 = (2.0 * 1200.0 + 210.0) * 0.28867513459481287;\r\n\r\n    /* Fcn: '<S7>/YB1' incorporates:\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->YB1 = 0.5 * 210.0;\r\n\r\n    /* Fcn: '<S7>/ZB1' */\r\n    c_coder_B->ZB1 = 0.0;\r\n\r\n    /* Fcn: '<S7>/XB2' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->XB2 = (1200.0 - 210.0) * -0.28867513459481287;\r\n\r\n    /* Fcn: '<S7>/YB2' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->YB2 = (1200.0 + 210.0) * 0.5;\r\n\r\n    /* Fcn: '<S7>/ZB2' */\r\n    c_coder_B->ZB2 = 0.0;\r\n\r\n    /* Fcn: '<S7>/XB3' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->XB3 = (2.0 * 210.0 + 1200.0) * -0.28867513459481287;\r\n\r\n    /* Fcn: '<S7>/YB3' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     */\r\n    c_coder_B->YB3 = 0.5 * 1200.0;\r\n\r\n    /* Fcn: '<S7>/ZB3' */\r\n    c_coder_B->ZB3 = 0.0;\r\n\r\n    /* Fcn: '<S7>/XB4' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->XB4 = (2.0 * 210.0 + 1200.0) * -0.28867513459481287;\r\n\r\n    /* Fcn: '<S7>/YB4' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     */\r\n    c_coder_B->YB4 = -0.5 * 1200.0;\r\n\r\n    /* Fcn: '<S7>/ZB4' */\r\n    c_coder_B->ZB4 = 0.0;\r\n\r\n    /* Fcn: '<S7>/XB5' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->XB5 = (1200.0 - 210.0) * -0.28867513459481287;\r\n\r\n    /* Fcn: '<S7>/YB5' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->YB5 = (1200.0 + 210.0) * -0.5;\r\n\r\n    /* Fcn: '<S7>/ZB5' */\r\n    c_coder_B->ZB5 = 0.0;\r\n\r\n    /* Fcn: '<S7>/XB6' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->XB6 = (2.0 * 1200.0 + 210.0) * 0.28867513459481287;\r\n\r\n    /* Fcn: '<S7>/YB6' incorporates:\r\n     *  Constant: '<S4>/Constant1'\r\n     */\r\n    c_coder_B->YB6 = -0.5 * 210.0;\r\n\r\n    /* Fcn: '<S7>/ZB6' */\r\n    c_coder_B->ZB6 = 0.0;\r\n\r\n    /* Fcn: '<S7>/CL6' */\r\n    tmp = c_coder_B->XT4 - c_coder_B->XB6;\r\n    tmp_idx_1 = rt_powd_snf(tmp, 2.0);\r\n    tmp_0 = c_coder_B->YT4 - c_coder_B->YB6;\r\n    tmp = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_0 = c_coder_B->ZT4 - c_coder_B->ZB6;\r\n    tmp_0 = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_idx_1 = (tmp_idx_1 + tmp) + tmp_0;\r\n    if (tmp_idx_1 < 0.0) {\r\n      tmp_idx_1 = -sqrt(-tmp_idx_1);\r\n    } else {\r\n      tmp_idx_1 = sqrt(tmp_idx_1);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL6' */\r\n    c_coder_B->CL6 = tmp_idx_1;\r\n\r\n    /* Sum: '<S7>/Add5' incorporates:\r\n     *  Constant: '<S4>/Constant4'\r\n     */\r\n    c_coder_B->Add5 = c_coder_B->CL6 - 750.0;\r\n\r\n    /* Product: '<S7>/Divide5' incorporates:\r\n     *  Constant: '<S4>/Constant6'\r\n     */\r\n    c_coder_B->Divide5 = c_coder_B->Add5 * 10.0;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* Product: '<S5>/Divide4' incorporates:\r\n       *  Constant: '<S5>/Constant6'\r\n       */\r\n      c_coder_B->Divide4 = c_coder_B->Divide5 / 256.0;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion16' */\r\n      tmp = floor(c_coder_B->Divide4);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion16' */\r\n      c_coder_B->DataTypeConversion16 = (int8_T)(tmp < 0.0 ? (int32_T)(int8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(int8_T)(uint8_T)tmp);\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion17' */\r\n      c_coder_B->DataTypeConversion17 = (uint8_T)c_coder_B->DataTypeConversion16;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion15' */\r\n      tmp = floor(c_coder_B->Divide5);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion15' */\r\n      c_coder_B->DataTypeConversion15 = (uint8_T)(tmp < 0.0 ? (int32_T)(uint8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(uint8_T)tmp);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL1' */\r\n    tmp = c_coder_B->XT3 - c_coder_B->XB1;\r\n    tmp_idx_1 = rt_powd_snf(tmp, 2.0);\r\n    tmp_0 = c_coder_B->YT3 - c_coder_B->YB1;\r\n    tmp = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_0 = c_coder_B->ZT3 - c_coder_B->ZB1;\r\n    tmp_0 = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_idx_1 = (tmp_idx_1 + tmp) + tmp_0;\r\n    if (tmp_idx_1 < 0.0) {\r\n      tmp_idx_1 = -sqrt(-tmp_idx_1);\r\n    } else {\r\n      tmp_idx_1 = sqrt(tmp_idx_1);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL1' */\r\n    c_coder_B->CL1 = tmp_idx_1;\r\n\r\n    /* Sum: '<S7>/Add' incorporates:\r\n     *  Constant: '<S4>/Constant4'\r\n     */\r\n    c_coder_B->Add = c_coder_B->CL1 - 750.0;\r\n\r\n    /* Product: '<S7>/Divide' incorporates:\r\n     *  Constant: '<S4>/Constant6'\r\n     */\r\n    c_coder_B->Divide = c_coder_B->Add * 10.0;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* Product: '<S5>/Divide1' incorporates:\r\n       *  Constant: '<S5>/Constant7'\r\n       */\r\n      c_coder_B->Divide1 = c_coder_B->Divide / 256.0;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion18' */\r\n      tmp = floor(c_coder_B->Divide1);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion18' */\r\n      c_coder_B->DataTypeConversion18 = (int8_T)(tmp < 0.0 ? (int32_T)(int8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(int8_T)(uint8_T)tmp);\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion4' */\r\n      c_coder_B->DataTypeConversion4_e = (uint8_T)\r\n        c_coder_B->DataTypeConversion18;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion2' */\r\n      tmp = floor(c_coder_B->Divide);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion2' */\r\n      c_coder_B->DataTypeConversion2 = (uint8_T)(tmp < 0.0 ? (int32_T)(uint8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(uint8_T)tmp);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL2' */\r\n    tmp = c_coder_B->XT2 - c_coder_B->XB2;\r\n    tmp_idx_1 = rt_powd_snf(tmp, 2.0);\r\n    tmp_0 = c_coder_B->YT2 - c_coder_B->YB2;\r\n    tmp = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_0 = c_coder_B->ZT2 - c_coder_B->ZB2;\r\n    tmp_0 = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_idx_1 = (tmp_idx_1 + tmp) + tmp_0;\r\n    if (tmp_idx_1 < 0.0) {\r\n      tmp_idx_1 = -sqrt(-tmp_idx_1);\r\n    } else {\r\n      tmp_idx_1 = sqrt(tmp_idx_1);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL2' */\r\n    c_coder_B->CL2 = tmp_idx_1;\r\n\r\n    /* Sum: '<S7>/Add1' incorporates:\r\n     *  Constant: '<S4>/Constant4'\r\n     */\r\n    c_coder_B->Add1 = c_coder_B->CL2 - 750.0;\r\n\r\n    /* Product: '<S7>/Divide1' incorporates:\r\n     *  Constant: '<S4>/Constant6'\r\n     */\r\n    c_coder_B->Divide1_a = c_coder_B->Add1 * 10.0;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* Product: '<S5>/Divide2' incorporates:\r\n       *  Constant: '<S5>/Constant9'\r\n       */\r\n      c_coder_B->Divide2 = c_coder_B->Divide1_a / 256.0;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion24' */\r\n      tmp = floor(c_coder_B->Divide2);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion24' */\r\n      c_coder_B->DataTypeConversion24 = (int8_T)(tmp < 0.0 ? (int32_T)(int8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(int8_T)(uint8_T)tmp);\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion20' */\r\n      c_coder_B->DataTypeConversion20 = (uint8_T)c_coder_B->DataTypeConversion24;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion19' */\r\n      tmp = floor(c_coder_B->Divide1_a);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion19' */\r\n      c_coder_B->DataTypeConversion19 = (uint8_T)(tmp < 0.0 ? (int32_T)(uint8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(uint8_T)tmp);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL3' */\r\n    tmp = c_coder_B->XT1 - c_coder_B->XB3;\r\n    tmp_idx_1 = rt_powd_snf(tmp, 2.0);\r\n    tmp_0 = c_coder_B->YT1 - c_coder_B->YB3;\r\n    tmp = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_0 = c_coder_B->ZT1 - c_coder_B->ZB3;\r\n    tmp_0 = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_idx_1 = (tmp_idx_1 + tmp) + tmp_0;\r\n    if (tmp_idx_1 < 0.0) {\r\n      tmp_idx_1 = -sqrt(-tmp_idx_1);\r\n    } else {\r\n      tmp_idx_1 = sqrt(tmp_idx_1);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL3' */\r\n    c_coder_B->CL3 = tmp_idx_1;\r\n\r\n    /* Sum: '<S7>/Add2' incorporates:\r\n     *  Constant: '<S4>/Constant4'\r\n     */\r\n    c_coder_B->Add2 = c_coder_B->CL3 - 750.0;\r\n\r\n    /* Product: '<S7>/Divide2' incorporates:\r\n     *  Constant: '<S4>/Constant6'\r\n     */\r\n    c_coder_B->Divide2_f = c_coder_B->Add2 * 10.0;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* Product: '<S5>/Divide3' incorporates:\r\n       *  Constant: '<S5>/Constant16'\r\n       */\r\n      c_coder_B->Divide3 = c_coder_B->Divide2_f / 256.0;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion25' */\r\n      tmp = floor(c_coder_B->Divide3);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion25' */\r\n      c_coder_B->DataTypeConversion25 = (int8_T)(tmp < 0.0 ? (int32_T)(int8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(int8_T)(uint8_T)tmp);\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion22' */\r\n      c_coder_B->DataTypeConversion22 = (uint8_T)c_coder_B->DataTypeConversion25;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion21' */\r\n      tmp = floor(c_coder_B->Divide2_f);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion21' */\r\n      c_coder_B->DataTypeConversion21 = (uint8_T)(tmp < 0.0 ? (int32_T)(uint8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(uint8_T)tmp);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL4' */\r\n    tmp = c_coder_B->XT6 - c_coder_B->XB4;\r\n    tmp_idx_1 = rt_powd_snf(tmp, 2.0);\r\n    tmp_0 = c_coder_B->YT6 - c_coder_B->YB4;\r\n    tmp = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_0 = c_coder_B->ZT6 - c_coder_B->ZB4;\r\n    tmp_0 = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_idx_1 = (tmp_idx_1 + tmp) + tmp_0;\r\n    if (tmp_idx_1 < 0.0) {\r\n      tmp_idx_1 = -sqrt(-tmp_idx_1);\r\n    } else {\r\n      tmp_idx_1 = sqrt(tmp_idx_1);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL4' */\r\n    c_coder_B->CL4 = tmp_idx_1;\r\n\r\n    /* Sum: '<S7>/Add3' incorporates:\r\n     *  Constant: '<S4>/Constant4'\r\n     */\r\n    c_coder_B->Add3 = c_coder_B->CL4 - 750.0;\r\n\r\n    /* Product: '<S7>/Divide3' incorporates:\r\n     *  Constant: '<S4>/Constant6'\r\n     */\r\n    c_coder_B->Divide3_f = c_coder_B->Add3 * 10.0;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* Product: '<S5>/Divide5' incorporates:\r\n       *  Constant: '<S5>/Constant18'\r\n       */\r\n      c_coder_B->Divide5_f = c_coder_B->Divide3_f / 256.0;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion26' */\r\n      tmp = floor(c_coder_B->Divide5_f);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion26' */\r\n      c_coder_B->DataTypeConversion26 = (int8_T)(tmp < 0.0 ? (int32_T)(int8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(int8_T)(uint8_T)tmp);\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion7' */\r\n      c_coder_B->DataTypeConversion7_i = (uint8_T)\r\n        c_coder_B->DataTypeConversion26;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion23' */\r\n      tmp = floor(c_coder_B->Divide3_f);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion23' */\r\n      c_coder_B->DataTypeConversion23 = (uint8_T)(tmp < 0.0 ? (int32_T)(uint8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(uint8_T)tmp);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL5' */\r\n    tmp = c_coder_B->XT5 - c_coder_B->XB5;\r\n    tmp_idx_1 = rt_powd_snf(tmp, 2.0);\r\n    tmp_0 = c_coder_B->YT5 - c_coder_B->YB5;\r\n    tmp = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_0 = c_coder_B->ZT5 - c_coder_B->ZB5;\r\n    tmp_0 = rt_powd_snf(tmp_0, 2.0);\r\n    tmp_idx_1 = (tmp_idx_1 + tmp) + tmp_0;\r\n    if (tmp_idx_1 < 0.0) {\r\n      tmp_idx_1 = -sqrt(-tmp_idx_1);\r\n    } else {\r\n      tmp_idx_1 = sqrt(tmp_idx_1);\r\n    }\r\n\r\n    /* Fcn: '<S7>/CL5' */\r\n    c_coder_B->CL5 = tmp_idx_1;\r\n\r\n    /* Sum: '<S7>/Add4' incorporates:\r\n     *  Constant: '<S4>/Constant4'\r\n     */\r\n    c_coder_B->Add4 = c_coder_B->CL5 - 750.0;\r\n\r\n    /* Product: '<S7>/Divide4' incorporates:\r\n     *  Constant: '<S4>/Constant6'\r\n     */\r\n    c_coder_B->Divide4_h = c_coder_B->Add4 * 10.0;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* Product: '<S5>/Divide6' incorporates:\r\n       *  Constant: '<S5>/Constant21'\r\n       */\r\n      c_coder_B->Divide6 = c_coder_B->Divide4_h / 256.0;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion27' */\r\n      tmp = floor(c_coder_B->Divide6);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion27' */\r\n      c_coder_B->DataTypeConversion27 = (int8_T)(tmp < 0.0 ? (int32_T)(int8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(int8_T)(uint8_T)tmp);\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion13' */\r\n      c_coder_B->DataTypeConversion13 = (uint8_T)c_coder_B->DataTypeConversion27;\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion10' */\r\n      tmp = floor(c_coder_B->Divide4_h);\r\n      if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n        tmp = 0.0;\r\n      } else {\r\n        tmp = fmod(tmp, 256.0);\r\n      }\r\n\r\n      /* DataTypeConversion: '<S5>/Data Type Conversion10' */\r\n      c_coder_B->DataTypeConversion10 = (uint8_T)(tmp < 0.0 ? (int32_T)(uint8_T)\r\n        -(int8_T)(uint8_T)-tmp : (int32_T)(uint8_T)tmp);\r\n\r\n      /* Outport: '<Root>/Out1' */\r\n      out1[0] = c_coder_ConstB.DataTypeConversion1;\r\n      out1[1] = c_coder_ConstB.DataTypeConversion;\r\n      out1[2] = c_coder_ConstB.DataTypeConversion5;\r\n      out1[3] = c_coder_ConstB.DataTypeConversion3;\r\n      out1[4] = c_coder_ConstB.DataTypeConversion8;\r\n      out1[5] = c_coder_ConstB.DataTypeConversion6;\r\n      out1[6] = c_coder_ConstB.DataTypeConversion11;\r\n      out1[7] = c_coder_ConstB.DataTypeConversion9;\r\n      out1[8] = c_coder_ConstB.DataTypeConversion14;\r\n      out1[9] = c_coder_ConstB.DataTypeConversion12;\r\n      out1[10] = c_coder_ConstB.DataTypeConversion30;\r\n      out1[11] = c_coder_ConstB.DataTypeConversion29;\r\n      out1[12] = c_coder_ConstB.DataTypeConversion28;\r\n      out1[13] = c_coder_B->DataTypeConversion17;\r\n      out1[14] = c_coder_B->DataTypeConversion15;\r\n      out1[15] = c_coder_B->DataTypeConversion4_e;\r\n      out1[16] = c_coder_B->DataTypeConversion2;\r\n      out1[17] = c_coder_B->DataTypeConversion20;\r\n      out1[18] = c_coder_B->DataTypeConversion19;\r\n      out1[19] = c_coder_B->DataTypeConversion22;\r\n      out1[20] = c_coder_B->DataTypeConversion21;\r\n      out1[21] = c_coder_B->DataTypeConversion7_i;\r\n      out1[22] = c_coder_B->DataTypeConversion23;\r\n      out1[23] = c_coder_B->DataTypeConversion13;\r\n      out1[24] = c_coder_B->DataTypeConversion10;\r\n    }\r\n\r\n    /* Derivative: '<Root>/Derivative1' */\r\n    if ((c_coder_DW->TimeStampA >= c_coder_M->Timing.t[0]) &&\r\n        (c_coder_DW->TimeStampB >= c_coder_M->Timing.t[0])) {\r\n      /* Derivative: '<Root>/Derivative1' */\r\n      c_coder_B->Derivative1 = 0.0;\r\n    } else {\r\n      tmp_idx_1 = c_coder_DW->TimeStampA;\r\n      lastU = &c_coder_DW->LastUAtTimeA;\r\n      if (c_coder_DW->TimeStampA < c_coder_DW->TimeStampB) {\r\n        if (c_coder_DW->TimeStampB < c_coder_M->Timing.t[0]) {\r\n          tmp_idx_1 = c_coder_DW->TimeStampB;\r\n          lastU = &c_coder_DW->LastUAtTimeB;\r\n        }\r\n      } else if (c_coder_DW->TimeStampA >= c_coder_M->Timing.t[0]) {\r\n        tmp_idx_1 = c_coder_DW->TimeStampB;\r\n        lastU = &c_coder_DW->LastUAtTimeB;\r\n      }\r\n\r\n      tmp_idx_1 = c_coder_M->Timing.t[0] - tmp_idx_1;\r\n\r\n      /* Derivative: '<Root>/Derivative1' */\r\n      c_coder_B->Derivative1 = (c_coder_B->posx_filt - *lastU) / tmp_idx_1;\r\n    }\r\n\r\n    /* End of Derivative: '<Root>/Derivative1' */\r\n\r\n    /* Derivative: '<Root>/Derivative2' */\r\n    if ((c_coder_DW->TimeStampA_c >= c_coder_M->Timing.t[0]) &&\r\n        (c_coder_DW->TimeStampB_c >= c_coder_M->Timing.t[0])) {\r\n      /* Derivative: '<Root>/Derivative2' */\r\n      c_coder_B->Derivative2 = 0.0;\r\n    } else {\r\n      tmp_idx_1 = c_coder_DW->TimeStampA_c;\r\n      lastU = &c_coder_DW->LastUAtTimeA_k;\r\n      if (c_coder_DW->TimeStampA_c < c_coder_DW->TimeStampB_c) {\r\n        if (c_coder_DW->TimeStampB_c < c_coder_M->Timing.t[0]) {\r\n          tmp_idx_1 = c_coder_DW->TimeStampB_c;\r\n          lastU = &c_coder_DW->LastUAtTimeB_o;\r\n        }\r\n      } else if (c_coder_DW->TimeStampA_c >= c_coder_M->Timing.t[0]) {\r\n        tmp_idx_1 = c_coder_DW->TimeStampB_c;\r\n        lastU = &c_coder_DW->LastUAtTimeB_o;\r\n      }\r\n\r\n      tmp_idx_1 = c_coder_M->Timing.t[0] - tmp_idx_1;\r\n\r\n      /* Derivative: '<Root>/Derivative2' */\r\n      c_coder_B->Derivative2 = (c_coder_B->Derivative1 - *lastU) / tmp_idx_1;\r\n    }\r\n\r\n    /* End of Derivative: '<Root>/Derivative2' */\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator2' */\r\n      c_coder_B->velx = c_coder_DW->DiscreteTimeIntegrator2_DSTATE;\r\n    }\r\n\r\n    /* DataTypeConversion: '<Root>/Cast2' incorporates:\r\n     *  Inport: '<Root>/Inport2'\r\n     */\r\n    c_coder_B->accx = c_coder_U_Inport2;\r\n\r\n    /* Gain: '<S2>/Gain5' */\r\n    c_coder_B->Gain5 = 1000.0 * c_coder_B->accx;\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn7' */\r\n    c_coder_B->accx_filt = 0.0;\r\n    c_coder_B->accx_filt += (-0.62831853071795862) *\r\n      c_coder_X->TransferFcn7_CSTATE;\r\n    c_coder_B->accx_filt += 1.0 * c_coder_B->Gain5;\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn10' */\r\n    c_coder_B->vrlx_filt = 0.0;\r\n    c_coder_B->vrlx_filt += (-1.8849555921538759) *\r\n      c_coder_X->TransferFcn10_CSTATE;\r\n    c_coder_B->vrlx_filt += 1.0 * c_coder_B->velx;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n    }\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn2' */\r\n    c_coder_B->TransferFcn2 = 0.0;\r\n    c_coder_B->TransferFcn2 += 0.0 * c_coder_X->TransferFcn2_CSTATE[0];\r\n    c_coder_B->TransferFcn2 += 62.831853071795862 *\r\n      c_coder_X->TransferFcn2_CSTATE[1];\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n    }\r\n\r\n    /* Derivative: '<Root>/Derivative3' */\r\n    if ((c_coder_DW->TimeStampA_j >= c_coder_M->Timing.t[0]) &&\r\n        (c_coder_DW->TimeStampB_m >= c_coder_M->Timing.t[0])) {\r\n      /* Derivative: '<Root>/Derivative3' */\r\n      c_coder_B->Derivative3 = 0.0;\r\n    } else {\r\n      tmp_idx_1 = c_coder_DW->TimeStampA_j;\r\n      lastU = &c_coder_DW->LastUAtTimeA_p;\r\n      if (c_coder_DW->TimeStampA_j < c_coder_DW->TimeStampB_m) {\r\n        if (c_coder_DW->TimeStampB_m < c_coder_M->Timing.t[0]) {\r\n          tmp_idx_1 = c_coder_DW->TimeStampB_m;\r\n          lastU = &c_coder_DW->LastUAtTimeB_oi;\r\n        }\r\n      } else if (c_coder_DW->TimeStampA_j >= c_coder_M->Timing.t[0]) {\r\n        tmp_idx_1 = c_coder_DW->TimeStampB_m;\r\n        lastU = &c_coder_DW->LastUAtTimeB_oi;\r\n      }\r\n\r\n      tmp_idx_1 = c_coder_M->Timing.t[0] - tmp_idx_1;\r\n\r\n      /* Derivative: '<Root>/Derivative3' */\r\n      c_coder_B->Derivative3 = (c_coder_B->Gain5 - *lastU) / tmp_idx_1;\r\n    }\r\n\r\n    /* End of Derivative: '<Root>/Derivative3' */\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator3' */\r\n      c_coder_B->DiscreteTimeIntegrator3 =\r\n        c_coder_DW->DiscreteTimeIntegrator3_DSTATE;\r\n    }\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn9' */\r\n    c_coder_B->TransferFcn9 = 0.0;\r\n    c_coder_B->TransferFcn9 += (-6.2831853071795862) *\r\n      c_coder_X->TransferFcn9_CSTATE;\r\n    c_coder_B->TransferFcn9 += 1.0 * c_coder_B->DiscreteTimeIntegrator3;\r\n\r\n    /* Saturate: '<Root>/Saturation5' */\r\n    tmp = c_coder_B->TransferFcn9;\r\n    tmp_idx_1 = (-250.0);\r\n    tmp_0 = 250.0;\r\n    if (tmp > tmp_0) {\r\n      /* Saturate: '<Root>/Saturation5' */\r\n      c_coder_B->Saturation5 = tmp_0;\r\n    } else if (tmp < tmp_idx_1) {\r\n      /* Saturate: '<Root>/Saturation5' */\r\n      c_coder_B->Saturation5 = tmp_idx_1;\r\n    } else {\r\n      /* Saturate: '<Root>/Saturation5' */\r\n      c_coder_B->Saturation5 = tmp;\r\n    }\r\n\r\n    /* End of Saturate: '<Root>/Saturation5' */\r\n\r\n    /* Sum: '<Root>/Sum3' incorporates:\r\n     *  Constant: '<Root>/Constant2'\r\n     */\r\n    c_coder_B->Sum3 = c_coder_B->Saturation5 + 1100.0;\r\n\r\n    /* DataTypeConversion: '<Root>/Cast' incorporates:\r\n     *  Inport: '<Root>/Inport'\r\n     */\r\n    c_coder_B->accy = c_coder_U_Inport;\r\n\r\n    /* DataTypeConversion: '<Root>/Cast1' incorporates:\r\n     *  Inport: '<Root>/Inport1'\r\n     */\r\n    c_coder_B->accz = c_coder_U_Inport1;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator10' */\r\n      c_coder_B->posy = c_coder_DW->DiscreteTimeIntegrator10_DSTATE;\r\n\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator9' */\r\n      c_coder_B->posz = c_coder_DW->DiscreteTimeIntegrator9_DSTATE;\r\n\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator11' */\r\n      c_coder_B->posx_a = c_coder_DW->DiscreteTimeIntegrator11_DSTATE;\r\n\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator7' */\r\n      c_coder_B->vely = c_coder_DW->DiscreteTimeIntegrator7_DSTATE;\r\n\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator6' */\r\n      c_coder_B->velz = c_coder_DW->DiscreteTimeIntegrator6_DSTATE;\r\n\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator8' */\r\n      c_coder_B->velx_m = c_coder_DW->DiscreteTimeIntegrator8_DSTATE;\r\n\r\n      /* Gain: '<Root>/Gain' */\r\n      c_coder_B->Gain = 3.6 * c_coder_B->velx_m;\r\n\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator' */\r\n      c_coder_B->DiscreteTimeIntegrator =\r\n        c_coder_DW->DiscreteTimeIntegrator_DSTATE;\r\n\r\n      /* DiscreteIntegrator: '<Root>/Discrete-Time Integrator1' */\r\n      c_coder_B->DiscreteTimeIntegrator1 =\r\n        c_coder_DW->DiscreteTimeIntegrator1_DSTATE;\r\n    }\r\n\r\n    /* Gain: '<S2>/Gain' */\r\n    c_coder_B->Gain_i = 1000.0 * c_coder_B->accy;\r\n\r\n    /* Gain: '<S2>/Gain1' */\r\n    c_coder_B->Gain1 = 1000.0 * c_coder_B->accz;\r\n\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion3' incorporates:\r\n     *  Inport: '<Root>/Inport2'\r\n     */\r\n    c_coder_B->DataTypeConversion3 = c_coder_U_Inport2;\r\n\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion4' incorporates:\r\n     *  Inport: '<Root>/Inport'\r\n     */\r\n    c_coder_B->DataTypeConversion4 = c_coder_U_Inport;\r\n\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion5' incorporates:\r\n     *  Inport: '<Root>/Inport1'\r\n     */\r\n    c_coder_B->DataTypeConversion5 = c_coder_U_Inport1;\r\n\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion6' incorporates:\r\n     *  Inport: '<Root>/Inport5'\r\n     */\r\n    c_coder_B->DataTypeConversion6 = c_coder_U_Inport5;\r\n\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion7' incorporates:\r\n     *  Inport: '<Root>/Inport3'\r\n     */\r\n    c_coder_B->DataTypeConversion7 = c_coder_U_Inport3;\r\n\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion8' incorporates:\r\n     *  Inport: '<Root>/Inport4'\r\n     */\r\n    c_coder_B->DataTypeConversion8 = c_coder_U_Inport4;\r\n\r\n    /* Saturate: '<Root>/Saturation3' */\r\n    tmp = c_coder_B->Switch[1];\r\n    tmp_idx_1 = (-15.0);\r\n    tmp_0 = 15.0;\r\n    if (tmp > tmp_0) {\r\n      /* Saturate: '<Root>/Saturation3' */\r\n      c_coder_B->Saturation3 = tmp_0;\r\n    } else if (tmp < tmp_idx_1) {\r\n      /* Saturate: '<Root>/Saturation3' */\r\n      c_coder_B->Saturation3 = tmp_idx_1;\r\n    } else {\r\n      /* Saturate: '<Root>/Saturation3' */\r\n      c_coder_B->Saturation3 = tmp;\r\n    }\r\n\r\n    /* End of Saturate: '<Root>/Saturation3' */\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn4' */\r\n    c_coder_B->TransferFcn4 = 0.0;\r\n    c_coder_B->TransferFcn4 += (-0.62831853071795862) *\r\n      c_coder_X->TransferFcn4_CSTATE;\r\n    c_coder_B->TransferFcn4 += 1.0 * c_coder_B->Gain1;\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn5' */\r\n    c_coder_B->TransferFcn5 = 0.0;\r\n    c_coder_B->TransferFcn5 += (-0.62831853071795862) *\r\n      c_coder_X->TransferFcn5_CSTATE;\r\n    c_coder_B->TransferFcn5 += 1.0 * c_coder_B->Gain_i;\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn6' */\r\n    c_coder_B->TransferFcn6 = 0.0;\r\n    c_coder_B->TransferFcn6 += (-1.8849555921538759) *\r\n      c_coder_X->TransferFcn6_CSTATE;\r\n    c_coder_B->TransferFcn6 += 1.0 * c_coder_B->DiscreteTimeIntegrator;\r\n\r\n    /* TransferFcn: '<Root>/Transfer Fcn8' */\r\n    c_coder_B->TransferFcn8 = 0.0;\r\n    c_coder_B->TransferFcn8 += (-1.8849555921538759) *\r\n      c_coder_X->TransferFcn8_CSTATE;\r\n    c_coder_B->TransferFcn8 += 1.0 * c_coder_B->DiscreteTimeIntegrator1;\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(c_coder_M)) {\r\n    real_T *lastU;\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator5' */\r\n      c_coder_DW->DiscreteTimeIntegrator5_DSTATE += 0.02 * c_coder_B->vrlx_filt;\r\n\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator4' */\r\n      c_coder_DW->DiscreteTimeIntegrator4_DSTATE += 0.02 *\r\n        c_coder_B->TransferFcn8;\r\n    }\r\n\r\n    /* Update for Derivative: '<Root>/Derivative1' */\r\n    if (c_coder_DW->TimeStampA == (rtInf)) {\r\n      c_coder_DW->TimeStampA = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeA;\r\n    } else if (c_coder_DW->TimeStampB == (rtInf)) {\r\n      c_coder_DW->TimeStampB = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeB;\r\n    } else if (c_coder_DW->TimeStampA < c_coder_DW->TimeStampB) {\r\n      c_coder_DW->TimeStampA = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeA;\r\n    } else {\r\n      c_coder_DW->TimeStampB = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeB;\r\n    }\r\n\r\n    *lastU = c_coder_B->posx_filt;\r\n\r\n    /* End of Update for Derivative: '<Root>/Derivative1' */\r\n\r\n    /* Update for Derivative: '<Root>/Derivative2' */\r\n    if (c_coder_DW->TimeStampA_c == (rtInf)) {\r\n      c_coder_DW->TimeStampA_c = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeA_k;\r\n    } else if (c_coder_DW->TimeStampB_c == (rtInf)) {\r\n      c_coder_DW->TimeStampB_c = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeB_o;\r\n    } else if (c_coder_DW->TimeStampA_c < c_coder_DW->TimeStampB_c) {\r\n      c_coder_DW->TimeStampA_c = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeA_k;\r\n    } else {\r\n      c_coder_DW->TimeStampB_c = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeB_o;\r\n    }\r\n\r\n    *lastU = c_coder_B->Derivative1;\r\n\r\n    /* End of Update for Derivative: '<Root>/Derivative2' */\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator2' */\r\n      c_coder_DW->DiscreteTimeIntegrator2_DSTATE += 0.02 * c_coder_B->accx_filt;\r\n    }\r\n\r\n    /* Update for Derivative: '<Root>/Derivative3' */\r\n    if (c_coder_DW->TimeStampA_j == (rtInf)) {\r\n      c_coder_DW->TimeStampA_j = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeA_p;\r\n    } else if (c_coder_DW->TimeStampB_m == (rtInf)) {\r\n      c_coder_DW->TimeStampB_m = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeB_oi;\r\n    } else if (c_coder_DW->TimeStampA_j < c_coder_DW->TimeStampB_m) {\r\n      c_coder_DW->TimeStampA_j = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeA_p;\r\n    } else {\r\n      c_coder_DW->TimeStampB_m = c_coder_M->Timing.t[0];\r\n      lastU = &c_coder_DW->LastUAtTimeB_oi;\r\n    }\r\n\r\n    *lastU = c_coder_B->Gain5;\r\n\r\n    /* End of Update for Derivative: '<Root>/Derivative3' */\r\n    if (rtmIsMajorTimeStep(c_coder_M)) {\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator3' */\r\n      c_coder_DW->DiscreteTimeIntegrator3_DSTATE += 0.02 *\r\n        c_coder_B->TransferFcn6;\r\n\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator10' */\r\n      c_coder_DW->DiscreteTimeIntegrator10_DSTATE += 0.02 * c_coder_B->vely;\r\n\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator9' */\r\n      c_coder_DW->DiscreteTimeIntegrator9_DSTATE += 0.02 * c_coder_B->velz;\r\n\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator11' */\r\n      c_coder_DW->DiscreteTimeIntegrator11_DSTATE += 0.02 * c_coder_B->velx_m;\r\n\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator7' */\r\n      c_coder_DW->DiscreteTimeIntegrator7_DSTATE += 0.02 * c_coder_B->accy;\r\n\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator6' */\r\n      c_coder_DW->DiscreteTimeIntegrator6_DSTATE += 0.02 * c_coder_B->accz;\r\n\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator8' */\r\n      c_coder_DW->DiscreteTimeIntegrator8_DSTATE += 0.02 * c_coder_B->accx;\r\n\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator' */\r\n      c_coder_DW->DiscreteTimeIntegrator_DSTATE += 0.02 *\r\n        c_coder_B->TransferFcn4;\r\n\r\n      /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator1' */\r\n      c_coder_DW->DiscreteTimeIntegrator1_DSTATE += 0.02 *\r\n        c_coder_B->TransferFcn5;\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(c_coder_M)) {\r\n    rt_ertODEUpdateContinuousStates(&c_coder_M->solverInfo, c_coder_M,\r\n      c_coder_U_Inport, c_coder_U_Inport1, c_coder_U_Inport2, c_coder_U_Inport3,\r\n      c_coder_U_Inport4, c_coder_U_Inport5);\r\n\r\n    /* Update absolute time for base rate */\r\n    /* The \"clockTick0\" counts the number of times the code of this task has\r\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n     * overflow during the application lifespan selected.\r\n     */\r\n    ++c_coder_M->Timing.clockTick0;\r\n    c_coder_M->Timing.t[0] = rtsiGetSolverStopTime(&c_coder_M->solverInfo);\r\n\r\n    {\r\n      /* Update absolute timer for sample time: [0.02s, 0.0s] */\r\n      /* The \"clockTick1\" counts the number of times the code of this task has\r\n       * been executed. The resolution of this integer timer is 0.02, which is the step size\r\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n       * application lifespan selected.\r\n       */\r\n      c_coder_M->Timing.clockTick1++;\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid c_coder_derivatives(RT_MODEL_c_coder_T *const c_coder_M)\r\n{\r\n  B_c_coder_T *c_coder_B = c_coder_M->blockIO;\r\n  X_c_coder_T *c_coder_X = c_coder_M->contStates;\r\n  XDot_c_coder_T *_rtXdot;\r\n  _rtXdot = ((XDot_c_coder_T *) c_coder_M->derivs);\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn13' */\r\n  _rtXdot->TransferFcn13_CSTATE = 0.0;\r\n  _rtXdot->TransferFcn13_CSTATE += (-6.2831853071795862) *\r\n    c_coder_X->TransferFcn13_CSTATE;\r\n  _rtXdot->TransferFcn13_CSTATE += c_coder_B->posx;\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn11' */\r\n  _rtXdot->TransferFcn11_CSTATE = 0.0;\r\n  _rtXdot->TransferFcn11_CSTATE += (-6.2831853071795862) *\r\n    c_coder_X->TransferFcn11_CSTATE;\r\n  _rtXdot->TransferFcn11_CSTATE += c_coder_B->DiscreteTimeIntegrator4;\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn7' */\r\n  _rtXdot->TransferFcn7_CSTATE = 0.0;\r\n  _rtXdot->TransferFcn7_CSTATE += (-0.62831853071795862) *\r\n    c_coder_X->TransferFcn7_CSTATE;\r\n  _rtXdot->TransferFcn7_CSTATE += c_coder_B->Gain5;\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn10' */\r\n  _rtXdot->TransferFcn10_CSTATE = 0.0;\r\n  _rtXdot->TransferFcn10_CSTATE += (-1.8849555921538759) *\r\n    c_coder_X->TransferFcn10_CSTATE;\r\n  _rtXdot->TransferFcn10_CSTATE += c_coder_B->velx;\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn2' */\r\n  _rtXdot->TransferFcn2_CSTATE[0] = 0.0;\r\n  _rtXdot->TransferFcn2_CSTATE[0] += (-125.66370614359172) *\r\n    c_coder_X->TransferFcn2_CSTATE[0];\r\n  _rtXdot->TransferFcn2_CSTATE[1] = 0.0;\r\n  _rtXdot->TransferFcn2_CSTATE[0] += (-62.831853071795862) *\r\n    c_coder_X->TransferFcn2_CSTATE[1];\r\n  _rtXdot->TransferFcn2_CSTATE[1] += c_coder_X->TransferFcn2_CSTATE[0];\r\n  _rtXdot->TransferFcn2_CSTATE[0] += c_coder_B->accx;\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn9' */\r\n  _rtXdot->TransferFcn9_CSTATE = 0.0;\r\n  _rtXdot->TransferFcn9_CSTATE += (-6.2831853071795862) *\r\n    c_coder_X->TransferFcn9_CSTATE;\r\n  _rtXdot->TransferFcn9_CSTATE += c_coder_B->DiscreteTimeIntegrator3;\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn4' */\r\n  _rtXdot->TransferFcn4_CSTATE = 0.0;\r\n  _rtXdot->TransferFcn4_CSTATE += (-0.62831853071795862) *\r\n    c_coder_X->TransferFcn4_CSTATE;\r\n  _rtXdot->TransferFcn4_CSTATE += c_coder_B->Gain1;\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn5' */\r\n  _rtXdot->TransferFcn5_CSTATE = 0.0;\r\n  _rtXdot->TransferFcn5_CSTATE += (-0.62831853071795862) *\r\n    c_coder_X->TransferFcn5_CSTATE;\r\n  _rtXdot->TransferFcn5_CSTATE += c_coder_B->Gain_i;\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn6' */\r\n  _rtXdot->TransferFcn6_CSTATE = 0.0;\r\n  _rtXdot->TransferFcn6_CSTATE += (-1.8849555921538759) *\r\n    c_coder_X->TransferFcn6_CSTATE;\r\n  _rtXdot->TransferFcn6_CSTATE += c_coder_B->DiscreteTimeIntegrator;\r\n\r\n  /* Derivatives for TransferFcn: '<Root>/Transfer Fcn8' */\r\n  _rtXdot->TransferFcn8_CSTATE = 0.0;\r\n  _rtXdot->TransferFcn8_CSTATE += (-1.8849555921538759) *\r\n    c_coder_X->TransferFcn8_CSTATE;\r\n  _rtXdot->TransferFcn8_CSTATE += c_coder_B->DiscreteTimeIntegrator1;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid c_coder_initialize(RT_MODEL_c_coder_T *const c_coder_M, real_T\r\n  *c_coder_U_Inport, real_T *c_coder_U_Inport1, real_T *c_coder_U_Inport2,\r\n  real_T *c_coder_U_Inport3, real_T *c_coder_U_Inport4, real_T\r\n  *c_coder_U_Inport5)\r\n{\r\n  DW_c_coder_T *c_coder_DW = c_coder_M->dwork;\r\n  X_c_coder_T *c_coder_X = c_coder_M->contStates;\r\n  B_c_coder_T *c_coder_B = c_coder_M->blockIO;\r\n\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&c_coder_M->solverInfo, &c_coder_M->Timing.simTimeStep);\r\n    rtsiSetTPtr(&c_coder_M->solverInfo, &rtmGetTPtr(c_coder_M));\r\n    rtsiSetStepSizePtr(&c_coder_M->solverInfo, &c_coder_M->Timing.stepSize0);\r\n    rtsiSetdXPtr(&c_coder_M->solverInfo, &c_coder_M->derivs);\r\n    rtsiSetContStatesPtr(&c_coder_M->solverInfo, (real_T **)\r\n                         &c_coder_M->contStates);\r\n    rtsiSetNumContStatesPtr(&c_coder_M->solverInfo,\r\n      &c_coder_M->Sizes.numContStates);\r\n    rtsiSetNumPeriodicContStatesPtr(&c_coder_M->solverInfo,\r\n      &c_coder_M->Sizes.numPeriodicContStates);\r\n    rtsiSetPeriodicContStateIndicesPtr(&c_coder_M->solverInfo,\r\n      &c_coder_M->periodicContStateIndices);\r\n    rtsiSetPeriodicContStateRangesPtr(&c_coder_M->solverInfo,\r\n      &c_coder_M->periodicContStateRanges);\r\n    rtsiSetErrorStatusPtr(&c_coder_M->solverInfo, (&rtmGetErrorStatus(c_coder_M)));\r\n    rtsiSetRTModelPtr(&c_coder_M->solverInfo, c_coder_M);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&c_coder_M->solverInfo, MAJOR_TIME_STEP);\r\n  c_coder_M->intgData.y = c_coder_M->odeY;\r\n  c_coder_M->intgData.f[0] = c_coder_M->odeF[0];\r\n  c_coder_M->intgData.f[1] = c_coder_M->odeF[1];\r\n  c_coder_M->intgData.f[2] = c_coder_M->odeF[2];\r\n  c_coder_M->contStates = ((X_c_coder_T *) c_coder_X);\r\n  rtsiSetSolverData(&c_coder_M->solverInfo, (void *)&c_coder_M->intgData);\r\n  rtsiSetSolverName(&c_coder_M->solverInfo,\"ode3\");\r\n  rtmSetTPtr(c_coder_M, &c_coder_M->Timing.tArray[0]);\r\n  c_coder_M->Timing.stepSize0 = 0.02;\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) c_coder_B), 0,\r\n                sizeof(B_c_coder_T));\r\n\r\n  /* states (continuous) */\r\n  {\r\n    (void) memset((void *)c_coder_X, 0,\r\n                  sizeof(X_c_coder_T));\r\n  }\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)c_coder_DW, 0,\r\n                sizeof(DW_c_coder_T));\r\n\r\n  /* external inputs */\r\n  *c_coder_U_Inport = 0.0;\r\n  *c_coder_U_Inport1 = 0.0;\r\n  *c_coder_U_Inport2 = 0.0;\r\n  *c_coder_U_Inport3 = 0.0;\r\n  *c_coder_U_Inport4 = 0.0;\r\n  *c_coder_U_Inport5 = 0.0;\r\n\r\n  /* external outputs */\r\n  (void)memset(&out1[0], 0, 25U * sizeof(uint8_T));\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn13' */\r\n  c_coder_X->TransferFcn13_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn11' */\r\n  c_coder_X->TransferFcn11_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for Derivative: '<Root>/Derivative1' */\r\n  c_coder_DW->TimeStampA = (rtInf);\r\n  c_coder_DW->TimeStampB = (rtInf);\r\n\r\n  /* InitializeConditions for Derivative: '<Root>/Derivative2' */\r\n  c_coder_DW->TimeStampA_c = (rtInf);\r\n  c_coder_DW->TimeStampB_c = (rtInf);\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn7' */\r\n  c_coder_X->TransferFcn7_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn10' */\r\n  c_coder_X->TransferFcn10_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn2' */\r\n  c_coder_X->TransferFcn2_CSTATE[0] = 0.0;\r\n  c_coder_X->TransferFcn2_CSTATE[1] = 0.0;\r\n\r\n  /* InitializeConditions for Derivative: '<Root>/Derivative3' */\r\n  c_coder_DW->TimeStampA_j = (rtInf);\r\n  c_coder_DW->TimeStampB_m = (rtInf);\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn9' */\r\n  c_coder_X->TransferFcn9_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn4' */\r\n  c_coder_X->TransferFcn4_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn5' */\r\n  c_coder_X->TransferFcn5_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn6' */\r\n  c_coder_X->TransferFcn6_CSTATE = 0.0;\r\n\r\n  /* InitializeConditions for TransferFcn: '<Root>/Transfer Fcn8' */\r\n  c_coder_X->TransferFcn8_CSTATE = 0.0;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid c_coder_terminate(RT_MODEL_c_coder_T *const c_coder_M)\r\n{\r\n  /* (no terminate code required) */\r\n  UNUSED_PARAMETER(c_coder_M);\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"c_coder.h","type":"header","group":"model","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: c_coder.h\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_c_coder_h_\r\n#define RTW_HEADER_c_coder_h_\r\n#include <math.h>\r\n#include <string.h>\r\n#ifndef c_coder_COMMON_INCLUDES_\r\n#define c_coder_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                                 /* c_coder_COMMON_INCLUDES_ */\r\n\r\n#include \"c_coder_types.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rt_defines.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n/* user code (top of header file) */\r\nextern void wrapper_c_coder_step(RT_MODEL_c_coder_T *const c_coder_M,\r\n  real_T c_coder_U_Inport,\r\n  real_T c_coder_U_Inport1,\r\n  real_T c_coder_U_Inport2,\r\n  real_T c_coder_U_Inport3,\r\n  real_T c_coder_U_Inport4,\r\n  real_T c_coder_U_Inport5);\r\nextern void wrapper_c_coder_initialize(RT_MODEL_c_coder_T *const c_coder_M,\r\n  real_T c_coder_U_Inport,\r\n  real_T c_coder_U_Inport1,\r\n  real_T c_coder_U_Inport2,\r\n  real_T c_coder_U_Inport3,\r\n  real_T c_coder_U_Inport4,\r\n  real_T c_coder_U_Inport5);\r\nextern int *getOutput();\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Sum2[3];                      /* '<Root>/Sum2' */\r\n  real_T Switch[3];                    /* '<Root>/Switch' */\r\n  real_T Gain3;                        /* '<Root>/Gain3' */\r\n  real_T Saturation2;                  /* '<Root>/Saturation2' */\r\n  real_T Product5;                     /* '<S8>/Product5' */\r\n  real_T TrigonometricFunction1;       /* '<S6>/Trigonometric Function1' */\r\n  real_T z;                            /* '<S6>/Product1' */\r\n  real_T Gain2;                        /* '<Root>/Gain2' */\r\n  real_T Saturation1;                  /* '<Root>/Saturation1' */\r\n  real_T Product5_e;                   /* '<S9>/Product5' */\r\n  real_T TrigonometricFunction2;       /* '<S6>/Trigonometric Function2' */\r\n  real_T x;                            /* '<S6>/Product2' */\r\n  real_T posx;                         /* '<Root>/Discrete-Time Integrator5' */\r\n  real_T TransferFcn13;                /* '<Root>/Transfer Fcn13' */\r\n  real_T posx_filt;                    /* '<Root>/Saturation6' */\r\n  real_T Sum;                          /* '<S6>/Sum' */\r\n  real_T TrigonometricFunction;        /* '<S6>/Trigonometric Function' */\r\n  real_T y;                            /* '<S6>/Product' */\r\n  real_T DiscreteTimeIntegrator4;      /* '<Root>/Discrete-Time Integrator4' */\r\n  real_T TransferFcn11;                /* '<Root>/Transfer Fcn11' */\r\n  real_T Saturation4;                  /* '<Root>/Saturation4' */\r\n  real_T Sum1;                         /* '<S6>/Sum1' */\r\n  real_T TrigonometricFunction3;       /* '<S6>/Trigonometric Function3' */\r\n  real_T z_n;                          /* '<S6>/Product3' */\r\n  real_T Sum2_n;                       /* '<S6>/Sum2' */\r\n  real_T XT1;                          /* '<S7>/XT1' */\r\n  real_T YT1;                          /* '<S7>/YT1' */\r\n  real_T ZT1;                          /* '<S7>/ZT1' */\r\n  real_T XT2;                          /* '<S7>/XT2' */\r\n  real_T YT2;                          /* '<S7>/YT2' */\r\n  real_T ZT2;                          /* '<S7>/ZT2' */\r\n  real_T XT3;                          /* '<S7>/XT3' */\r\n  real_T YT3;                          /* '<S7>/YT3' */\r\n  real_T ZT3;                          /* '<S7>/ZT3' */\r\n  real_T XT4;                          /* '<S7>/XT4' */\r\n  real_T YT4;                          /* '<S7>/YT4' */\r\n  real_T ZT4;                          /* '<S7>/ZT4' */\r\n  real_T XT5;                          /* '<S7>/XT5' */\r\n  real_T YT5;                          /* '<S7>/YT5' */\r\n  real_T ZT5;                          /* '<S7>/ZT5' */\r\n  real_T XT6;                          /* '<S7>/XT6' */\r\n  real_T YT6;                          /* '<S7>/YT6' */\r\n  real_T ZT6;                          /* '<S7>/ZT6' */\r\n  real_T XB1;                          /* '<S7>/XB1' */\r\n  real_T YB1;                          /* '<S7>/YB1' */\r\n  real_T ZB1;                          /* '<S7>/ZB1' */\r\n  real_T XB2;                          /* '<S7>/XB2' */\r\n  real_T YB2;                          /* '<S7>/YB2' */\r\n  real_T ZB2;                          /* '<S7>/ZB2' */\r\n  real_T XB3;                          /* '<S7>/XB3' */\r\n  real_T YB3;                          /* '<S7>/YB3' */\r\n  real_T ZB3;                          /* '<S7>/ZB3' */\r\n  real_T XB4;                          /* '<S7>/XB4' */\r\n  real_T YB4;                          /* '<S7>/YB4' */\r\n  real_T ZB4;                          /* '<S7>/ZB4' */\r\n  real_T XB5;                          /* '<S7>/XB5' */\r\n  real_T YB5;                          /* '<S7>/YB5' */\r\n  real_T ZB5;                          /* '<S7>/ZB5' */\r\n  real_T XB6;                          /* '<S7>/XB6' */\r\n  real_T YB6;                          /* '<S7>/YB6' */\r\n  real_T ZB6;                          /* '<S7>/ZB6' */\r\n  real_T CL6;                          /* '<S7>/CL6' */\r\n  real_T Add5;                         /* '<S7>/Add5' */\r\n  real_T Divide5;                      /* '<S7>/Divide5' */\r\n  real_T Divide4;                      /* '<S5>/Divide4' */\r\n  real_T CL1;                          /* '<S7>/CL1' */\r\n  real_T Add;                          /* '<S7>/Add' */\r\n  real_T Divide;                       /* '<S7>/Divide' */\r\n  real_T Divide1;                      /* '<S5>/Divide1' */\r\n  real_T CL2;                          /* '<S7>/CL2' */\r\n  real_T Add1;                         /* '<S7>/Add1' */\r\n  real_T Divide1_a;                    /* '<S7>/Divide1' */\r\n  real_T Divide2;                      /* '<S5>/Divide2' */\r\n  real_T CL3;                          /* '<S7>/CL3' */\r\n  real_T Add2;                         /* '<S7>/Add2' */\r\n  real_T Divide2_f;                    /* '<S7>/Divide2' */\r\n  real_T Divide3;                      /* '<S5>/Divide3' */\r\n  real_T CL4;                          /* '<S7>/CL4' */\r\n  real_T Add3;                         /* '<S7>/Add3' */\r\n  real_T Divide3_f;                    /* '<S7>/Divide3' */\r\n  real_T Divide5_f;                    /* '<S5>/Divide5' */\r\n  real_T CL5;                          /* '<S7>/CL5' */\r\n  real_T Add4;                         /* '<S7>/Add4' */\r\n  real_T Divide4_h;                    /* '<S7>/Divide4' */\r\n  real_T Divide6;                      /* '<S5>/Divide6' */\r\n  real_T Derivative1;                  /* '<Root>/Derivative1' */\r\n  real_T Derivative2;                  /* '<Root>/Derivative2' */\r\n  real_T accx;                         /* '<Root>/Cast2' */\r\n  real_T Gain5;                        /* '<S2>/Gain5' */\r\n  real_T accx_filt;                    /* '<Root>/Transfer Fcn7' */\r\n  real_T velx;                         /* '<Root>/Discrete-Time Integrator2' */\r\n  real_T vrlx_filt;                    /* '<Root>/Transfer Fcn10' */\r\n  real_T TransferFcn2;                 /* '<Root>/Transfer Fcn2' */\r\n  real_T Derivative3;                  /* '<Root>/Derivative3' */\r\n  real_T DiscreteTimeIntegrator3;      /* '<Root>/Discrete-Time Integrator3' */\r\n  real_T TransferFcn9;                 /* '<Root>/Transfer Fcn9' */\r\n  real_T Saturation5;                  /* '<Root>/Saturation5' */\r\n  real_T Sum3;                         /* '<Root>/Sum3' */\r\n  real_T accy;                         /* '<Root>/Cast' */\r\n  real_T accz;                         /* '<Root>/Cast1' */\r\n  real_T posy;                         /* '<Root>/Discrete-Time Integrator10' */\r\n  real_T posz;                         /* '<Root>/Discrete-Time Integrator9' */\r\n  real_T posx_a;                       /* '<Root>/Discrete-Time Integrator11' */\r\n  real_T vely;                         /* '<Root>/Discrete-Time Integrator7' */\r\n  real_T velz;                         /* '<Root>/Discrete-Time Integrator6' */\r\n  real_T velx_m;                       /* '<Root>/Discrete-Time Integrator8' */\r\n  real_T Gain;                         /* '<Root>/Gain' */\r\n  real_T Gain_i;                       /* '<S2>/Gain' */\r\n  real_T Gain1;                        /* '<S2>/Gain1' */\r\n  real_T DataTypeConversion3;          /* '<Root>/Data Type Conversion3' */\r\n  real_T DataTypeConversion4;          /* '<Root>/Data Type Conversion4' */\r\n  real_T DataTypeConversion5;          /* '<Root>/Data Type Conversion5' */\r\n  real_T DataTypeConversion6;          /* '<Root>/Data Type Conversion6' */\r\n  real_T DataTypeConversion7;          /* '<Root>/Data Type Conversion7' */\r\n  real_T DataTypeConversion8;          /* '<Root>/Data Type Conversion8' */\r\n  real_T DiscreteTimeIntegrator;       /* '<Root>/Discrete-Time Integrator' */\r\n  real_T DiscreteTimeIntegrator1;      /* '<Root>/Discrete-Time Integrator1' */\r\n  real_T Saturation3;                  /* '<Root>/Saturation3' */\r\n  real_T TransferFcn4;                 /* '<Root>/Transfer Fcn4' */\r\n  real_T TransferFcn5;                 /* '<Root>/Transfer Fcn5' */\r\n  real_T TransferFcn6;                 /* '<Root>/Transfer Fcn6' */\r\n  real_T TransferFcn8;                 /* '<Root>/Transfer Fcn8' */\r\n  uint8_T DataTypeConversion17;        /* '<S5>/Data Type Conversion17' */\r\n  uint8_T DataTypeConversion15;        /* '<S5>/Data Type Conversion15' */\r\n  uint8_T DataTypeConversion4_e;       /* '<S5>/Data Type Conversion4' */\r\n  uint8_T DataTypeConversion2;         /* '<S5>/Data Type Conversion2' */\r\n  uint8_T DataTypeConversion20;        /* '<S5>/Data Type Conversion20' */\r\n  uint8_T DataTypeConversion19;        /* '<S5>/Data Type Conversion19' */\r\n  uint8_T DataTypeConversion22;        /* '<S5>/Data Type Conversion22' */\r\n  uint8_T DataTypeConversion21;        /* '<S5>/Data Type Conversion21' */\r\n  uint8_T DataTypeConversion7_i;       /* '<S5>/Data Type Conversion7' */\r\n  uint8_T DataTypeConversion23;        /* '<S5>/Data Type Conversion23' */\r\n  uint8_T DataTypeConversion13;        /* '<S5>/Data Type Conversion13' */\r\n  uint8_T DataTypeConversion10;        /* '<S5>/Data Type Conversion10' */\r\n  int8_T DataTypeConversion16;         /* '<S5>/Data Type Conversion16' */\r\n  int8_T DataTypeConversion18;         /* '<S5>/Data Type Conversion18' */\r\n  int8_T DataTypeConversion24;         /* '<S5>/Data Type Conversion24' */\r\n  int8_T DataTypeConversion25;         /* '<S5>/Data Type Conversion25' */\r\n  int8_T DataTypeConversion26;         /* '<S5>/Data Type Conversion26' */\r\n  int8_T DataTypeConversion27;         /* '<S5>/Data Type Conversion27' */\r\n  boolean_T Compare[3];                /* '<S1>/Compare' */\r\n} B_c_coder_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T DiscreteTimeIntegrator5_DSTATE;/* '<Root>/Discrete-Time Integrator5' */\r\n  real_T DiscreteTimeIntegrator4_DSTATE;/* '<Root>/Discrete-Time Integrator4' */\r\n  real_T DiscreteTimeIntegrator2_DSTATE;/* '<Root>/Discrete-Time Integrator2' */\r\n  real_T DiscreteTimeIntegrator3_DSTATE;/* '<Root>/Discrete-Time Integrator3' */\r\n  real_T DiscreteTimeIntegrator10_DSTATE;/* '<Root>/Discrete-Time Integrator10' */\r\n  real_T DiscreteTimeIntegrator9_DSTATE;/* '<Root>/Discrete-Time Integrator9' */\r\n  real_T DiscreteTimeIntegrator11_DSTATE;/* '<Root>/Discrete-Time Integrator11' */\r\n  real_T DiscreteTimeIntegrator7_DSTATE;/* '<Root>/Discrete-Time Integrator7' */\r\n  real_T DiscreteTimeIntegrator6_DSTATE;/* '<Root>/Discrete-Time Integrator6' */\r\n  real_T DiscreteTimeIntegrator8_DSTATE;/* '<Root>/Discrete-Time Integrator8' */\r\n  real_T DiscreteTimeIntegrator_DSTATE;/* '<Root>/Discrete-Time Integrator' */\r\n  real_T DiscreteTimeIntegrator1_DSTATE;/* '<Root>/Discrete-Time Integrator1' */\r\n  real_T TimeStampA;                   /* '<Root>/Derivative1' */\r\n  real_T LastUAtTimeA;                 /* '<Root>/Derivative1' */\r\n  real_T TimeStampB;                   /* '<Root>/Derivative1' */\r\n  real_T LastUAtTimeB;                 /* '<Root>/Derivative1' */\r\n  real_T TimeStampA_c;                 /* '<Root>/Derivative2' */\r\n  real_T LastUAtTimeA_k;               /* '<Root>/Derivative2' */\r\n  real_T TimeStampB_c;                 /* '<Root>/Derivative2' */\r\n  real_T LastUAtTimeB_o;               /* '<Root>/Derivative2' */\r\n  real_T TimeStampA_j;                 /* '<Root>/Derivative3' */\r\n  real_T LastUAtTimeA_p;               /* '<Root>/Derivative3' */\r\n  real_T TimeStampB_m;                 /* '<Root>/Derivative3' */\r\n  real_T LastUAtTimeB_oi;              /* '<Root>/Derivative3' */\r\n} DW_c_coder_T;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T TransferFcn13_CSTATE;         /* '<Root>/Transfer Fcn13' */\r\n  real_T TransferFcn11_CSTATE;         /* '<Root>/Transfer Fcn11' */\r\n  real_T TransferFcn7_CSTATE;          /* '<Root>/Transfer Fcn7' */\r\n  real_T TransferFcn10_CSTATE;         /* '<Root>/Transfer Fcn10' */\r\n  real_T TransferFcn2_CSTATE[2];       /* '<Root>/Transfer Fcn2' */\r\n  real_T TransferFcn9_CSTATE;          /* '<Root>/Transfer Fcn9' */\r\n  real_T TransferFcn4_CSTATE;          /* '<Root>/Transfer Fcn4' */\r\n  real_T TransferFcn5_CSTATE;          /* '<Root>/Transfer Fcn5' */\r\n  real_T TransferFcn6_CSTATE;          /* '<Root>/Transfer Fcn6' */\r\n  real_T TransferFcn8_CSTATE;          /* '<Root>/Transfer Fcn8' */\r\n} X_c_coder_T;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T TransferFcn13_CSTATE;         /* '<Root>/Transfer Fcn13' */\r\n  real_T TransferFcn11_CSTATE;         /* '<Root>/Transfer Fcn11' */\r\n  real_T TransferFcn7_CSTATE;          /* '<Root>/Transfer Fcn7' */\r\n  real_T TransferFcn10_CSTATE;         /* '<Root>/Transfer Fcn10' */\r\n  real_T TransferFcn2_CSTATE[2];       /* '<Root>/Transfer Fcn2' */\r\n  real_T TransferFcn9_CSTATE;          /* '<Root>/Transfer Fcn9' */\r\n  real_T TransferFcn4_CSTATE;          /* '<Root>/Transfer Fcn4' */\r\n  real_T TransferFcn5_CSTATE;          /* '<Root>/Transfer Fcn5' */\r\n  real_T TransferFcn6_CSTATE;          /* '<Root>/Transfer Fcn6' */\r\n  real_T TransferFcn8_CSTATE;          /* '<Root>/Transfer Fcn8' */\r\n} XDot_c_coder_T;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T TransferFcn13_CSTATE;      /* '<Root>/Transfer Fcn13' */\r\n  boolean_T TransferFcn11_CSTATE;      /* '<Root>/Transfer Fcn11' */\r\n  boolean_T TransferFcn7_CSTATE;       /* '<Root>/Transfer Fcn7' */\r\n  boolean_T TransferFcn10_CSTATE;      /* '<Root>/Transfer Fcn10' */\r\n  boolean_T TransferFcn2_CSTATE[2];    /* '<Root>/Transfer Fcn2' */\r\n  boolean_T TransferFcn9_CSTATE;       /* '<Root>/Transfer Fcn9' */\r\n  boolean_T TransferFcn4_CSTATE;       /* '<Root>/Transfer Fcn4' */\r\n  boolean_T TransferFcn5_CSTATE;       /* '<Root>/Transfer Fcn5' */\r\n  boolean_T TransferFcn6_CSTATE;       /* '<Root>/Transfer Fcn6' */\r\n  boolean_T TransferFcn8_CSTATE;       /* '<Root>/Transfer Fcn8' */\r\n} XDis_c_coder_T;\r\n\r\n/* Invariant block signals (default storage) */\r\ntypedef struct {\r\n  const real_T Gain4;                  /* '<Root>/Gain4' */\r\n  const real_T Saturation;             /* '<Root>/Saturation' */\r\n  const real_T Product5;               /* '<S10>/Product5' */\r\n  const uint8_T DataTypeConversion;    /* '<S5>/Data Type Conversion' */\r\n  const uint8_T DataTypeConversion1;   /* '<S5>/Data Type Conversion1' */\r\n  const uint8_T DataTypeConversion11;  /* '<S5>/Data Type Conversion11' */\r\n  const uint8_T DataTypeConversion12;  /* '<S5>/Data Type Conversion12' */\r\n  const uint8_T DataTypeConversion14;  /* '<S5>/Data Type Conversion14' */\r\n  const uint8_T DataTypeConversion28;  /* '<S5>/Data Type Conversion28' */\r\n  const uint8_T DataTypeConversion29;  /* '<S5>/Data Type Conversion29' */\r\n  const uint8_T DataTypeConversion3;   /* '<S5>/Data Type Conversion3' */\r\n  const uint8_T DataTypeConversion30;  /* '<S5>/Data Type Conversion30' */\r\n  const uint8_T DataTypeConversion5;   /* '<S5>/Data Type Conversion5' */\r\n  const uint8_T DataTypeConversion6;   /* '<S5>/Data Type Conversion6' */\r\n  const uint8_T DataTypeConversion8;   /* '<S5>/Data Type Conversion8' */\r\n  const uint8_T DataTypeConversion9;   /* '<S5>/Data Type Conversion9' */\r\n} ConstB_c_coder_T;\r\n\r\n#ifndef ODE3_INTG\r\n#define ODE3_INTG\r\n\r\n/* ODE3 Integration Data */\r\ntypedef struct {\r\n  real_T *y;                           /* output */\r\n  real_T *f[3];                        /* derivatives */\r\n} ODE3_IntgData;\r\n\r\n#endif\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_c_coder_T {\r\n  const char_T *errorStatus;\r\n  RTWSolverInfo solverInfo;\r\n  B_c_coder_T *blockIO;\r\n  X_c_coder_T *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  boolean_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  real_T odeY[11];\r\n  real_T odeF[3][11];\r\n  ODE3_IntgData intgData;\r\n  DW_c_coder_T *dwork;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numSampTimes;\r\n  } Sizes;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *t;\r\n    time_T tArray[2];\r\n  } Timing;\r\n};\r\n\r\nextern const ConstB_c_coder_T c_coder_ConstB;/* constant block i/o */\r\n\r\n/*\r\n * Exported Global Signals\r\n *\r\n * Note: Exported global signals are block signals with an exported global\r\n * storage class designation.  Code generation will declare the memory for\r\n * these signals and export their symbols.\r\n *\r\n */\r\nextern uint8_T out1[25];               /* '<Root>/Out1' */\r\n\r\n/* Model entry point functions */\r\nextern void c_coder_initialize(RT_MODEL_c_coder_T *const c_coder_M, real_T\r\n  *c_coder_U_Inport, real_T *c_coder_U_Inport1, real_T *c_coder_U_Inport2,\r\n  real_T *c_coder_U_Inport3, real_T *c_coder_U_Inport4, real_T\r\n  *c_coder_U_Inport5);\r\nextern void c_coder_step(RT_MODEL_c_coder_T *const c_coder_M, real_T\r\n  c_coder_U_Inport, real_T c_coder_U_Inport1, real_T c_coder_U_Inport2, real_T\r\n  c_coder_U_Inport3, real_T c_coder_U_Inport4, real_T c_coder_U_Inport5);\r\nextern void c_coder_terminate(RT_MODEL_c_coder_T *const c_coder_M);\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'c_coder'\r\n * '<S1>'   : 'c_coder/Compare To Constant'\r\n * '<S2>'   : 'c_coder/Convert m to mm'\r\n * '<S3>'   : 'c_coder/Subsystem'\r\n * '<S4>'   : 'c_coder/Subsystem/Cinemtica Inversa Plataforma 6Dof'\r\n * '<S5>'   : 'c_coder/Subsystem/Escrever 20.01 a 20.06 UNIDRIVE SP ModBus TCP//IP'\r\n * '<S6>'   : 'c_coder/Subsystem/Cinemtica Inversa Plataforma 6Dof/Cinematica aux'\r\n * '<S7>'   : 'c_coder/Subsystem/Cinemtica Inversa Plataforma 6Dof/Cinematica Inversa'\r\n * '<S8>'   : 'c_coder/Subsystem/Cinemtica Inversa Plataforma 6Dof/Deg=>Rad'\r\n * '<S9>'   : 'c_coder/Subsystem/Cinemtica Inversa Plataforma 6Dof/Deg=>Rad1'\r\n * '<S10>'  : 'c_coder/Subsystem/Cinemtica Inversa Plataforma 6Dof/Deg=>Rad2'\r\n */\r\n#endif                                 /* RTW_HEADER_c_coder_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"c_coder_private.h","type":"header","group":"model","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: c_coder_private.h\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_c_coder_private_h_\r\n#define RTW_HEADER_c_coder_private_h_\r\n#include \"rtwtypes.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\nextern real_T rt_powd_snf(real_T u0, real_T u1);\r\n\r\n/* private model entry point functions */\r\nextern void c_coder_derivatives(RT_MODEL_c_coder_T *const c_coder_M);\r\n\r\n#endif                                 /* RTW_HEADER_c_coder_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"c_coder_types.h","type":"header","group":"model","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: c_coder_types.h\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_c_coder_types_h_\r\n#define RTW_HEADER_c_coder_types_h_\r\n\r\n/* Model Code Variants */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_c_coder_T RT_MODEL_c_coder_T;\r\n\r\n#endif                                 /* RTW_HEADER_c_coder_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"c_coder_data.c","type":"source","group":"data","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * File: c_coder_data.c\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"c_coder.h\"\r\n#include \"c_coder_private.h\"\r\n\r\n/* Invariant block signals (default storage) */\r\nconst ConstB_c_coder_T c_coder_ConstB = {\r\n  -0.0,                                /* '<Root>/Gain4' */\r\n  -0.0,                                /* '<Root>/Saturation' */\r\n  -0.0,                                /* '<S10>/Product5' */\r\n  2U,                                  /* '<S5>/Data Type Conversion' */\r\n  0U,                                  /* '<S5>/Data Type Conversion1' */\r\n  1U,                                  /* '<S5>/Data Type Conversion11' */\r\n  208U,                                /* '<S5>/Data Type Conversion12' */\r\n  7U,                                  /* '<S5>/Data Type Conversion14' */\r\n  12U,                                 /* '<S5>/Data Type Conversion28' */\r\n  6U,                                  /* '<S5>/Data Type Conversion29' */\r\n  0U,                                  /* '<S5>/Data Type Conversion3' */\r\n  0U,                                  /* '<S5>/Data Type Conversion30' */\r\n  0U,                                  /* '<S5>/Data Type Conversion5' */\r\n  19U,                                 /* '<S5>/Data Type Conversion6' */\r\n  0U,                                  /* '<S5>/Data Type Conversion8' */\r\n  16U                                  /* '<S5>/Data Type Conversion9' */\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, Inf\r\n */\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, NaN\r\n */\r\n#include \"rtGetNaN.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_defines.h\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_defines_h_\r\n#define RTW_HEADER_rt_defines_h_\r\n\r\n/*===========*\r\n * Constants *\r\n *===========*/\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n/*\r\n * UNUSED_PARAMETER(x)\r\n *   Used to specify that a function parameter (argument) is required but not\r\n *   accessed by the function body.\r\n */\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\r\n#else\r\n\r\n/*\r\n * This is the semi-ANSI standard way of indicating that an\r\n * unused function parameter is required.\r\n */\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n#endif                                 /* RTW_HEADER_rt_defines_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finites,\r\n *      (Inf, NaN and -Inf).\r\n */\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\filip\\Documents\\ISEL\\TFM\\Repositorio\\tfm-simulador\\MATLAB\\c_coder_ert_shrlib_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'c_coder'.\r\n *\r\n * Model version                  : 8.145\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Feb 14 05:36:51 2024\r\n *\r\n * Target selection: ert_shrlib.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: MATLAB Host\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  64\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};